"use strict";(self.webpackChunkrke_docs=self.webpackChunkrke_docs||[]).push([[4443],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=d(n),h=a,k=u["".concat(l,".").concat(h)]||u[h]||c[h]||o;return n?r.createElement(k,i(i({ref:t},p),{},{components:n})):r.createElement(k,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5043:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return c}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],s={title:"Nodes",weight:210},l=void 0,d={unversionedId:"config-options/nodes/nodes",id:"config-options/nodes/nodes",title:"Nodes",description:"The nodes directive is the only required section in the cluster.yml file. It's used by RKE to specify cluster node(s), ssh credentials used to access the node(s) and which roles these nodes will be in the Kubernetes cluster.",source:"@site/docs/config-options/nodes/nodes.md",sourceDirName:"config-options/nodes",slug:"/config-options/nodes/",permalink:"/rke1-docs/config-options/nodes/",draft:!1,editUrl:"https://github.com/rancher/rke1-docs/edit/main/docs/config-options/nodes/nodes.md",tags:[],version:"current",lastUpdatedAt:1673985426,formattedLastUpdatedAt:"1/17/2023",frontMatter:{title:"Nodes",weight:210},sidebar:"mySidebar",previous:{title:"Kubernetes Configuration Options",permalink:"/rke1-docs/config-options/"},next:{title:"Private Registries",permalink:"/rke1-docs/config-options/private-registries/"}},p={},c=[{value:"etcd",id:"etcd",level:3},{value:"Controlplane",id:"controlplane",level:3},{value:"Worker",id:"worker",level:3},{value:"Address",id:"address",level:3},{value:"Internal Address",id:"internal-address",level:3},{value:"Overriding the Hostname",id:"overriding-the-hostname",level:3},{value:"SSH Port",id:"ssh-port",level:3},{value:"SSH Users",id:"ssh-users",level:3},{value:"SSH Key Path",id:"ssh-key-path",level:3},{value:"SSH Key",id:"ssh-key",level:3},{value:"SSH Certificate Path",id:"ssh-certificate-path",level:3},{value:"SSH Certificate",id:"ssh-certificate",level:3},{value:"Docker Socket",id:"docker-socket",level:3},{value:"Labels",id:"labels",level:3},{value:"Taints",id:"taints",level:3}],u={toc:c};function h(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"nodes")," directive is the only required section in the ",(0,o.kt)("inlineCode",{parentName:"p"},"cluster.yml")," file. It's used by RKE to specify cluster node(s), ssh credentials used to access the node(s) and which roles these nodes will be in the Kubernetes cluster."),(0,o.kt)("p",null,"This section covers the following topics:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#node-configuration-example"},"Node configuration example")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#kubernetes-roles"},"Kubernetes roles"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#etcd"},"etcd")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#controlplane"},"Controlplane")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#worker"},"Worker")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#node-options"},"Node options"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#address"},"Address")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#internal-address"},"Internal address")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#overriding-the-hostname"},"Overriding the hostname")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ssh-port"},"SSH port")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ssh-users"},"SSH users")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ssh-key-path"},"SSH key path")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ssh-key"},"SSH key")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ssh-certificate-path"},"SSH certificate path")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ssh-certificate"},"SSH certificate")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#docker-socket"},"Docker socket")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#labels"},"Labels")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#taints"},"Taints"))))),(0,o.kt)("h1",{id:"node-configuration-example"},"Node Configuration Example"),(0,o.kt)("p",null,"The following example shows node configuration in an example ",(0,o.kt)("inlineCode",{parentName:"p"},"cluster.yml"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"nodes:\n    - address: 1.1.1.1\n      user: ubuntu\n      role:\n      - controlplane\n      - etcd\n      ssh_key_path: /home/user/.ssh/id_rsa\n      port: 2222\n    - address: 2.2.2.2\n      user: ubuntu\n      role:\n      - worker\n      ssh_key: |-\n        -----BEGIN RSA PRIVATE KEY-----\n\n        -----END RSA PRIVATE KEY-----\n    - address: 3.3.3.3\n      user: ubuntu\n      role:\n      - worker\n      ssh_key_path: /home/user/.ssh/id_rsa\n      ssh_cert_path: /home/user/.ssh/id_rsa-cert.pub\n    - address: 4.4.4.4\n      user: ubuntu\n      role:\n      - worker\n      ssh_key_path: /home/user/.ssh/id_rsa\n      ssh_cert: |-\n        ssh-rsa-cert-v01@openssh.com AAAAHHNza...\n      taints: # Available as of v0.3.0\n        - key: test-key\n          value: test-value\n          effect: NoSchedule\n    - address: example.com\n      user: ubuntu\n      role:\n      - worker\n      hostname_override: node3\n      internal_address: 192.168.1.6\n      labels:\n        app: ingress\n")),(0,o.kt)("h1",{id:"kubernetes-roles"},"Kubernetes Roles"),(0,o.kt)("p",null,"You can specify the list of roles that you want the node to be as part of the Kubernetes cluster. Three roles are supported: ",(0,o.kt)("inlineCode",{parentName:"p"},"controlplane"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"etcd")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"worker"),". Node roles are not mutually exclusive. It's possible to assign any combination of roles to any node. It's also possible to change a node's role using the upgrade process."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," Before v0.1.8, workloads/pods might have run on any nodes with ",(0,o.kt)("inlineCode",{parentName:"p"},"worker")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"controlplane")," roles, but as of v0.1.8, they will only be deployed to any ",(0,o.kt)("inlineCode",{parentName:"p"},"worker")," nodes.")),(0,o.kt)("h3",{id:"etcd"},"etcd"),(0,o.kt)("p",null,"With this role, the ",(0,o.kt)("inlineCode",{parentName:"p"},"etcd")," container will be run on these nodes.  Etcd keeps the state of your cluster and is the most important component in your cluster, single source of truth of your cluster. Although you can run etcd on just one node, it typically takes 3, 5 or more nodes to create an HA configuration. Etcd is a distributed reliable key-value store which stores all Kubernetes state. ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/"},"Taint set on nodes")," with the ",(0,o.kt)("strong",{parentName:"p"},"etcd")," role is shown below:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Taint Key"),(0,o.kt)("th",{parentName:"tr",align:null},"Taint Value"),(0,o.kt)("th",{parentName:"tr",align:null},"Taint Effect"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"node-role.kubernetes.io/etcd")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"true")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"NoExecute"))))),(0,o.kt)("h3",{id:"controlplane"},"Controlplane"),(0,o.kt)("p",null,"With this role, the stateless components that are used to deploy Kubernetes will run on these nodes. These components are used to run the API server, scheduler, and controllers. ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/"},"Taint set on nodes")," with the ",(0,o.kt)("strong",{parentName:"p"},"controlplane")," role is shown below:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Taint Key"),(0,o.kt)("th",{parentName:"tr",align:null},"Taint Value"),(0,o.kt)("th",{parentName:"tr",align:null},"Taint Effect"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"node-role.kubernetes.io/controlplane")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"true")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"NoSchedule"))))),(0,o.kt)("h3",{id:"worker"},"Worker"),(0,o.kt)("p",null,"With this role, any workloads or pods that are deployed will land on these nodes."),(0,o.kt)("h1",{id:"node-options"},"Node Options"),(0,o.kt)("p",null,"Within each node, there are multiple directives that can be used."),(0,o.kt)("h3",{id:"address"},"Address"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," directive will be used to set the hostname or IP address of the node. RKE must be able to connect to this address."),(0,o.kt)("h3",{id:"internal-address"},"Internal Address"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"internal_address")," provides the ability to have nodes with multiple addresses set a specific address to use for inter-host communication on a private network. If the ",(0,o.kt)("inlineCode",{parentName:"p"},"internal_address")," is not set, the ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," is used for inter-host communication. The ",(0,o.kt)("inlineCode",{parentName:"p"},"internal_address")," directive will set the address used for inter-host communication of the Kubernetes components, e.g. kube-apiserver and etcd. To change the interface used for the vxlan traffic of the Canal or Flannel network plug-ins please refer to the ",(0,o.kt)("a",{parentName:"p",href:"config-options/add-ons/network-plugins/"},"Network Plug-ins Documentation"),"."),(0,o.kt)("h3",{id:"overriding-the-hostname"},"Overriding the Hostname"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"hostname_override")," is used to be able to provide a friendly name for RKE to use when registering the node in Kubernetes. This hostname doesn't need to be a routable address, but it must be a valid ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"},"Kubernetes resource name"),". If the ",(0,o.kt)("inlineCode",{parentName:"p"},"hostname_override")," isn't set, then the ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," directive is used when registering the node in Kubernetes."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," When ",(0,o.kt)("a",{parentName:"p",href:"config-options/cloud-providers/"},"cloud providers")," are configured, you may need to override the hostname in order to use the cloud provider correctly. There is an exception for the ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/#aws"},"AWS cloud provider"),", where the ",(0,o.kt)("inlineCode",{parentName:"p"},"hostname_override")," field will be explicitly ignored.")),(0,o.kt)("h3",{id:"ssh-port"},"SSH Port"),(0,o.kt)("p",null,"In each node, you specify which ",(0,o.kt)("inlineCode",{parentName:"p"},"port")," to be used when connecting to this node. The default port is ",(0,o.kt)("inlineCode",{parentName:"p"},"22"),"."),(0,o.kt)("h3",{id:"ssh-users"},"SSH Users"),(0,o.kt)("p",null,"For each node, you specify the ",(0,o.kt)("inlineCode",{parentName:"p"},"user")," to be used when connecting to this node. This user must be a member of the Docker group or allowed to write to the node's Docker socket."),(0,o.kt)("h3",{id:"ssh-key-path"},"SSH Key Path"),(0,o.kt)("p",null,"For each node, you specify the path, i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"ssh_key_path"),", for the SSH private key to be used when connecting to this node. The default key path for each node is ",(0,o.kt)("inlineCode",{parentName:"p"},"~/.ssh/id_rsa"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," If you have a private key that can be used across all nodes, you can set the ",(0,o.kt)("a",{parentName:"p",href:"config-options/#cluster-level-ssh-key-path"},"SSH key path at the cluster level"),". The SSH key path set in each node will always take precedence.")),(0,o.kt)("h3",{id:"ssh-key"},"SSH Key"),(0,o.kt)("p",null,"Instead of setting the path to the SSH key, you can alternatively specify the actual key, i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"ssh_key"),", to be used to connect to the node."),(0,o.kt)("h3",{id:"ssh-certificate-path"},"SSH Certificate Path"),(0,o.kt)("p",null,"For each node, you can specify the path, i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"ssh_cert_path"),", for the signed SSH certificate to be used when connecting to this node."),(0,o.kt)("h3",{id:"ssh-certificate"},"SSH Certificate"),(0,o.kt)("p",null,"Instead of setting the path to the signed SSH certificate, you can alternatively specify the actual certificate, i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"ssh_cert"),", to be used to connect to the node."),(0,o.kt)("h3",{id:"docker-socket"},"Docker Socket"),(0,o.kt)("p",null,"If the Docker socket is different than the default, you can set the ",(0,o.kt)("inlineCode",{parentName:"p"},"docker_socket"),". The default is ",(0,o.kt)("inlineCode",{parentName:"p"},"/var/run/docker.sock")),(0,o.kt)("h3",{id:"labels"},"Labels"),(0,o.kt)("p",null,"You have the ability to add an arbitrary map of labels for each node. It can be used when using the ",(0,o.kt)("a",{parentName:"p",href:"config-options/add-ons/ingress-controllers/"},"ingress controller's")," ",(0,o.kt)("inlineCode",{parentName:"p"},"node_selector")," option."),(0,o.kt)("h3",{id:"taints"},"Taints"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Available as of v0.3.0")),(0,o.kt)("p",null,"You have the ability to add ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/"},"taints")," for each node."))}h.isMDXComponent=!0}}]);