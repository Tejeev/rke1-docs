"use strict";(self.webpackChunkrke_docs=self.webpackChunkrke_docs||[]).push([[8835],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),s=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},k=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,u=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=s(n),k=a,m=p["".concat(u,".").concat(k)]||p[k]||c[k]||l;return n?r.createElement(m,o(o({ref:t},d),{},{components:n})):r.createElement(m,o({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=k;var i={};for(var u in t)hasOwnProperty.call(t,u)&&(i[u]=t[u]);i.originalType=e,i[p]="string"==typeof e?e:a,o[1]=i;for(var s=2;s<l;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}k.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>o});var r=n(7294),a=n(4334);const l={tabItem:"tabItem_Ymn6"};function o(e){let{children:t,hidden:n,className:o}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(l.tabItem,o),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>v});var r=n(3117),a=n(7294),l=n(4334),o=n(2466),i=n(6775),u=n(1980),s=n(7392),d=n(12);function p(e){return function(e){return a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:a}}=e;return{value:t,label:n,attributes:r,default:a}}))}function c(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,s.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function k(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const r=(0,i.k6)(),l=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,u._X)(l),(0,a.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(r.location.search);t.set(l,e),r.replace({...r.location,search:t.toString()})}),[l,r])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,l=c(e),[o,i]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!k({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:l}))),[u,s]=m({queryString:n,groupId:r}),[p,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,l]=(0,d.Nk)(n);return[r,(0,a.useCallback)((e=>{n&&l.set(e)}),[n,l])]}({groupId:r}),h=(()=>{const e=u??p;return k({value:e,tabValues:l})?e:null})();(0,a.useLayoutEffect)((()=>{h&&i(h)}),[h]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!k({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);i(e),s(e),g(e)}),[s,g,l]),tabValues:l}}var h=n(2389);const N={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:t,block:n,selectedValue:i,selectValue:u,tabValues:s}=e;const d=[],{blockElementScrollPositionUntilNextRender:p}=(0,o.o5)(),c=e=>{const t=e.currentTarget,n=d.indexOf(t),r=s[n].value;r!==i&&(p(t),u(r))},k=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=d.indexOf(e.currentTarget)+1;t=d[n]??d[0];break}case"ArrowLeft":{const n=d.indexOf(e.currentTarget)-1;t=d[n]??d[d.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":n},t)},s.map((e=>{let{value:t,label:n,attributes:o}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>d.push(e),onKeyDown:k,onClick:c},o,{className:(0,l.Z)("tabs__item",N.tabItem,o?.className,{"tabs__item--active":i===t})}),n??t)})))}function b(e){let{lazy:t,children:n,selectedValue:r}=e;const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function y(e){const t=g(e);return a.createElement("div",{className:(0,l.Z)("tabs-container",N.tabList)},a.createElement(f,(0,r.Z)({},e,t)),a.createElement(b,(0,r.Z)({},e,t)))}function v(e){const t=(0,h.Z)();return a.createElement(y,(0,r.Z)({key:String(t)},e))}},7398:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>m,default:()=>y,frontMatter:()=>k,metadata:()=>g,toc:()=>N});var r=n(3117),a=(n(7294),n(3905)),l=n(4866),o=n(5162);const i={toc:[{value:"RKE node - Outbound rules",id:"rke-node---outbound-rules",level:3}]},u="wrapper";function s(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"RKE node:"),"\nNode that runs the ",(0,a.kt)("inlineCode",{parentName:"p"},"rke")," commands"),(0,a.kt)("h3",{id:"rke-node---outbound-rules"},"RKE node - Outbound rules"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Protocol"),(0,a.kt)("th",{parentName:"tr",align:null},"Port"),(0,a.kt)("th",{parentName:"tr",align:null},"Source"),(0,a.kt)("th",{parentName:"tr",align:null},"Destination"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"22"),(0,a.kt)("td",{parentName:"tr",align:null},"RKE node"),(0,a.kt)("td",{parentName:"tr",align:null},"Any node configured in Cluster Configuration File"),(0,a.kt)("td",{parentName:"tr",align:null},"SSH provisioning of node by RKE")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"6443"),(0,a.kt)("td",{parentName:"tr",align:null},"RKE node"),(0,a.kt)("td",{parentName:"tr",align:null},"Control plane nodes"),(0,a.kt)("td",{parentName:"tr",align:null},"Kubernetes API server")))))}s.isMDXComponent=!0;const d={toc:[{value:"etcd nodes - Inbound rules",id:"etcd-nodes---inbound-rules",level:3},{value:"etcd nodes - Outbound rules",id:"etcd-nodes---outbound-rules",level:3},{value:"controlplane nodes - Inbound rules",id:"controlplane-nodes---inbound-rules",level:3},{value:"controlplane nodes - Outbound rules",id:"controlplane-nodes---outbound-rules",level:3},{value:"Worker nodes - Inbound rules",id:"worker-nodes---inbound-rules",level:3},{value:"Worker nodes - Outbound rules",id:"worker-nodes---outbound-rules",level:3},{value:"Information on local node traffic",id:"information-on-local-node-traffic",level:3}]},p="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"etcd nodes:")," Nodes with the role ",(0,a.kt)("strong",{parentName:"p"},"etcd")),(0,a.kt)("h3",{id:"etcd-nodes---inbound-rules"},"etcd nodes - Inbound rules"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Protocol"),(0,a.kt)("th",{parentName:"tr",align:null},"Port"),(0,a.kt)("th",{parentName:"tr",align:null},"Source"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"2376"),(0,a.kt)("td",{parentName:"tr",align:null},"Rancher nodes"),(0,a.kt)("td",{parentName:"tr",align:null},"Docker daemon TLS port used by Docker Machine (only needed when using Node Driver/Templates)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"2379"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"),(0,a.kt)("li",null,"controlplane nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"etcd client requests")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"2380"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"),(0,a.kt)("li",null,"controlplane nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"etcd peer communication")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"UDP"),(0,a.kt)("td",{parentName:"tr",align:null},"8472"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"),(0,a.kt)("li",null,"controlplane nodes"),(0,a.kt)("li",null,"worker nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel VXLAN overlay networking")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"9099"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd node itself (",(0,a.kt)("a",{parentName:"td",href:"#information-on-local-node-traffic"},"local traffic"),", not across nodes)"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel livenessProbe/readinessProbe")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"10250"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Metrics server communications with all nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"kubelet")))),(0,a.kt)("h3",{id:"etcd-nodes---outbound-rules"},"etcd nodes - Outbound rules"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Protocol"),(0,a.kt)("th",{parentName:"tr",align:null},"Port"),(0,a.kt)("th",{parentName:"tr",align:null},"Destination"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"443"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Rancher nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Rancher agent")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"379"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"etcd client requests")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"2380"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"etcd peer communication")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"6443"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"controlplane nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Kubernetes apiserver")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"UDP"),(0,a.kt)("td",{parentName:"tr",align:null},"8472"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"),(0,a.kt)("li",null,"controlplane nodes"),(0,a.kt)("li",null,"worker nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel VXLAN overlay networking")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"9099"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd node itself (",(0,a.kt)("a",{parentName:"td",href:"#information-on-local-node-traffic"},"local traffic"),", not across nodes)"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel livenessProbe/readinessProbe")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"controlplane nodes:")," Nodes with the role ",(0,a.kt)("strong",{parentName:"p"},"controlplane")),(0,a.kt)("h3",{id:"controlplane-nodes---inbound-rules"},"controlplane nodes - Inbound rules"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Protocol"),(0,a.kt)("th",{parentName:"tr",align:null},"Port"),(0,a.kt)("th",{parentName:"tr",align:null},"Source"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"80"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Any that consumes Ingress services"))),(0,a.kt)("td",{parentName:"tr",align:null},"Ingress controller (HTTP)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"443"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Any that consumes Ingress services"))),(0,a.kt)("td",{parentName:"tr",align:null},"Ingress controller (HTTPS)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"2376"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Rancher nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Docker daemon TLS port used by Docker Machine (only needed when using Node Driver/Templates)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"6443"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"),(0,a.kt)("li",null,"controlplane nodes"),(0,a.kt)("li",null,"worker nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Kubernetes apiserver")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"UDP"),(0,a.kt)("td",{parentName:"tr",align:null},"472"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"),(0,a.kt)("li",null,"controlplane nodes"),(0,a.kt)("li",null,"worker nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel VXLAN overlay networking")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"9099"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"controlplane node itself (",(0,a.kt)("a",{parentName:"td",href:"#information-on-local-node-traffic"},"local traffic"),", not across nodes)"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel livenessProbe/readinessProbe")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"10250"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Metrics server communications with all nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"kubelet")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"10254"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"controlplane node itself (",(0,a.kt)("a",{parentName:"td",href:"#information-on-local-node-traffic"},"local traffic"),", not across nodes)"))),(0,a.kt)("td",{parentName:"tr",align:null},"Ingress controller livenessProbe/readinessProbe")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP/UDP"),(0,a.kt)("td",{parentName:"tr",align:null},"30000-32767"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Any source that consumes NodePort services"))),(0,a.kt)("td",{parentName:"tr",align:null},"NodePort port range")))),(0,a.kt)("h3",{id:"controlplane-nodes---outbound-rules"},"controlplane nodes - Outbound rules"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Protocol"),(0,a.kt)("th",{parentName:"tr",align:null},"Port"),(0,a.kt)("th",{parentName:"tr",align:null},"Destination"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"443"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Rancher nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Rancher agent")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"2379"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"etcd client requests")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"2380"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"etcd peer communication")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"UDP"),(0,a.kt)("td",{parentName:"tr",align:null},"8472"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"),(0,a.kt)("li",null,"controlplane nodes"),(0,a.kt)("li",null,"worker nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel VXLAN overlay networking")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"9099"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"controlplane node itself (",(0,a.kt)("a",{parentName:"td",href:"#information-on-local-node-traffic"},"local traffic"),", not across nodes)"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel livenessProbe/readinessProbe")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"10250"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"),(0,a.kt)("li",null,"controlplane nodes"),(0,a.kt)("li",null,"worker nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"kubelet")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Worker nodes:")," Nodes with the role ",(0,a.kt)("strong",{parentName:"p"},"worker")),(0,a.kt)("h3",{id:"worker-nodes---inbound-rules"},"Worker nodes - Inbound rules"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Protocol"),(0,a.kt)("th",{parentName:"tr",align:null},"Port"),(0,a.kt)("th",{parentName:"tr",align:null},"Source"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"22"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,(0,a.kt)("strong",{parentName:"td"},"Linux worker nodes only")),(0,a.kt)("li",null,"Any network that you want to be able to remotely access this node from."))),(0,a.kt)("td",{parentName:"tr",align:null},"Remote access over SSH")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"3389"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,(0,a.kt)("strong",{parentName:"td"},"Windows worker nodes only")),(0,a.kt)("li",null,"Any network that you want to be able to remotely access this node from."))),(0,a.kt)("td",{parentName:"tr",align:null},"Remote access over RDP")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"80"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Any that consumes Ingress services"))),(0,a.kt)("td",{parentName:"tr",align:null},"Ingress controller (HTTP)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"443"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Any that consumes Ingress services"))),(0,a.kt)("td",{parentName:"tr",align:null},"Ingress controller (HTTPS)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"2376"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Rancher nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Docker daemon TLS port used by Docker Machine only needed when using Node Driver/Templates)")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"UDP"),(0,a.kt)("td",{parentName:"tr",align:null},"8472"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"),(0,a.kt)("li",null,"controlplane nodes"),(0,a.kt)("li",null,"worker nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel VXLAN overlay networking")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"9099"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"worker node itself (",(0,a.kt)("a",{parentName:"td",href:"#information-on-local-node-traffic"},"local traffic"),", not across nodes)"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel livenessProbe/readinessProbe")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"10250"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Metrics server communications with all nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"kubelet")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"10254"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"worker node itself (",(0,a.kt)("a",{parentName:"td",href:"#information-on-local-node-traffic"},"local traffic"),", not across nodes)"))),(0,a.kt)("td",{parentName:"tr",align:null},"Ingress controller livenessProbe/readinessProbe")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP/UDP"),(0,a.kt)("td",{parentName:"tr",align:null},"30000-32767"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Any source that consumes NodePort services"))),(0,a.kt)("td",{parentName:"tr",align:null},"NodePort port range")))),(0,a.kt)("h3",{id:"worker-nodes---outbound-rules"},"Worker nodes - Outbound rules"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Protocol"),(0,a.kt)("th",{parentName:"tr",align:null},"Port"),(0,a.kt)("th",{parentName:"tr",align:null},"Destination"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"443"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Rancher nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Rancher agent")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"6443"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"controlplane nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Kubernetes apiserver")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"UDP"),(0,a.kt)("td",{parentName:"tr",align:null},"8472"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"etcd nodes"),(0,a.kt)("li",null,"controlplane nodes"),(0,a.kt)("li",null,"worker nodes"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel VXLAN overlay networking")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"9099"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"worker node itself (",(0,a.kt)("a",{parentName:"td",href:"#information-on-local-node-traffic"},"local traffic"),", not across nodes)"))),(0,a.kt)("td",{parentName:"tr",align:null},"Canal/Flannel livenessProbe/readinessProbe")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TCP"),(0,a.kt)("td",{parentName:"tr",align:null},"10254"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"worker node itself (",(0,a.kt)("a",{parentName:"td",href:"#information-on-local-node-traffic"},"local traffic"),", not across nodes)"))),(0,a.kt)("td",{parentName:"tr",align:null},"Ingress controller livenessProbe/readinessProbe")))),(0,a.kt)("h3",{id:"information-on-local-node-traffic"},"Information on local node traffic"),(0,a.kt)("p",null,"Kubernetes health checks (",(0,a.kt)("inlineCode",{parentName:"p"},"livenessProbe")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"readinessProbe"),") are executed on the host itself. On most nodes, this is allowed by default. When you have applied strict host firewall (i.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"ptables"),") policies on the node, or when you are using nodes that have multiple interfaces (multi-homed), this traffic gets blocked. In this case, you have to explicitly allow this traffic in your host firewall, or in case of public/private cloud hosted machines (i.e. AWS or OpenStack), in your security group configuration. Keep in mind that when using a security group as Source or Destination in your security group, that this only applies to the private interface of the nodes/instances."))}c.isMDXComponent=!0;const k={title:"Requirements"},m=void 0,g={unversionedId:"os/os",id:"os/os",title:"Requirements",description:"Operating System",source:"@site/docs/os/os.md",sourceDirName:"os",slug:"/os/",permalink:"/os/",draft:!1,editUrl:"https://github.com/rancher/rke1-docs/edit/main/docs/os/os.md",tags:[],version:"current",lastUpdatedAt:1692351929,formattedLastUpdatedAt:"Aug 18, 2023",frontMatter:{title:"Requirements"},sidebar:"mySidebar",previous:{title:"Overview of RKE",permalink:"/"},next:{title:"RKE Kubernetes Installation",permalink:"/installation/"}},h={},N=[{value:"Operating System",id:"operating-system",level:2},{value:"General Linux Requirements",id:"general-linux-requirements",level:3},{value:"SUSE Linux Enterprise Server (SLES) / openSUSE",id:"suse-linux-enterprise-server-sles--opensuse",level:3},{value:"Using upstream Docker",id:"using-upstream-docker",level:4},{value:"Using SUSE/openSUSE packaged docker",id:"using-suseopensuse-packaged-docker",level:4},{value:"Adding the Software repository for docker",id:"adding-the-software-repository-for-docker",level:4},{value:"openSUSE MicroOS/Kubic (Atomic)",id:"opensuse-microoskubic-atomic",level:3},{value:"openSUSE MicroOS",id:"opensuse-microos",level:4},{value:"openSUSE Kubic",id:"opensuse-kubic",level:4},{value:"Red Hat Enterprise Linux (RHEL) / Oracle Linux (OL) / CentOS",id:"red-hat-enterprise-linux-rhel--oracle-linux-ol--centos",level:3},{value:"Using upstream Docker",id:"using-upstream-docker-1",level:4},{value:"Using RHEL/CentOS packaged Docker",id:"using-rhelcentos-packaged-docker",level:4},{value:"Red Hat Atomic",id:"red-hat-atomic",level:3},{value:"OpenSSH version",id:"openssh-version",level:4},{value:"Creating a Docker Group",id:"creating-a-docker-group",level:4},{value:"Flatcar Container Linux",id:"flatcar-container-linux",level:3},{value:"Software",id:"software",level:2},{value:"OpenSSH",id:"openssh",level:3},{value:"Kubernetes",id:"kubernetes",level:3},{value:"Docker",id:"docker",level:3},{value:"Installing Docker",id:"installing-docker",level:3},{value:"Checking the Installed Docker Version",id:"checking-the-installed-docker-version",level:3},{value:"Hardware",id:"hardware",level:2},{value:"Worker Role",id:"worker-role",level:3},{value:"Large Kubernetes Clusters",id:"large-kubernetes-clusters",level:3},{value:"Etcd Clusters",id:"etcd-clusters",level:3},{value:"Ports",id:"ports",level:2},{value:"Opening port TCP/6443 using <code>iptables</code>",id:"opening-port-tcp6443-using-iptables",level:3},{value:"Opening port TCP/6443 using <code>firewalld</code>",id:"opening-port-tcp6443-using-firewalld",level:3},{value:"SSH Server Configuration",id:"ssh-server-configuration",level:2}],f={toc:N},b="wrapper";function y(e){let{components:t,...n}=e;return(0,a.kt)(b,(0,r.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"operating-system"},"Operating System"),(0,a.kt)("h3",{id:"general-linux-requirements"},"General Linux Requirements"),(0,a.kt)("p",null,"RKE runs on almost any Linux OS with Docker installed. For details on which OS and Docker versions were tested with each version, refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://www.suse.com/suse-rke1/support-matrix/all-supported-versions/"},"support matrix"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"/config-options/nodes/#ssh-users"},"SSH user")," - The SSH user used for node access must be a member of the ",(0,a.kt)("inlineCode",{parentName:"p"},"docker")," group on the node:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"usermod -aG docker <user_name>\n")))),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Users added to the ",(0,a.kt)("inlineCode",{parentName:"p"},"docker")," group are granted effective root permissions on the host by means of the Docker API. Only choose a user that is intended for this purpose and has its credentials and access properly secured.")),(0,a.kt)("p",null,"   See ",(0,a.kt)("a",{parentName:"p",href:"https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user"},"Manage Docker as a non-root user")," to see how you can configure access to Docker without using the ",(0,a.kt)("inlineCode",{parentName:"p"},"root")," user."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Swap should be disabled on any worker nodes")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Please check the network plugin documentation for any additional requirements (for example, kernel modules)"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.projectcalico.org/getting-started/kubernetes/requirements#kernel-dependencies"},"Calico")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/flannel-io/flannel/tree/master/Documentation"},"Flannel")),(0,a.kt)("li",{parentName:"ul"},"Canal (Combination Calico and Flannel)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.weave.works/docs/net/latest/install/installing-weave/"},"Weave")," (Deprecated)")))),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"If you or your cloud provider are using a custom minimal kernel, some required (network) kernel modules might not be present.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Following sysctl settings must be applied")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"net.bridge.bridge-nf-call-iptables=1\n")),(0,a.kt)("h3",{id:"suse-linux-enterprise-server-sles--opensuse"},"SUSE Linux Enterprise Server (SLES) / openSUSE"),(0,a.kt)("p",null,"If you are using SUSE Linux Enterprise Server or openSUSE follow the instructions below."),(0,a.kt)("h4",{id:"using-upstream-docker"},"Using upstream Docker"),(0,a.kt)("p",null,"If you are using upstream Docker, the package name is ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-ce")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-ee"),". You can check the installed package by executing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"rpm -q docker-ce\n")),(0,a.kt)("p",null,"When using the upstream Docker packages, please follow ",(0,a.kt)("a",{parentName:"p",href:"https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user"},"Manage Docker as a non-root user"),"."),(0,a.kt)("h4",{id:"using-suseopensuse-packaged-docker"},"Using SUSE/openSUSE packaged docker"),(0,a.kt)("p",null,"If you are using the Docker package supplied by SUSE/openSUSE, the package name is ",(0,a.kt)("inlineCode",{parentName:"p"},"docker"),". You can check the installed package by executing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"rpm -q docker\n")),(0,a.kt)("h4",{id:"adding-the-software-repository-for-docker"},"Adding the Software repository for docker"),(0,a.kt)("p",null,"In SUSE Linux Enterprise Server 15 SP2 docker is found in the Containers module.\nThis module will need to be added before istalling docker."),(0,a.kt)("p",null,"To list available modules you can run SUSEConnect to list the extensions and the activation command"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"node:~ # SUSEConnect --list-extensions\nAVAILABLE EXTENSIONS AND MODULES\n\n    Basesystem Module 15 SP2 x86_64 (Activated)\n    Deactivate with: SUSEConnect -d -p sle-module-basesystem/15.2/x86_64\n\n        Containers Module 15 SP2 x86_64\n        Activate with: SUSEConnect -p sle-module-containers/15.2/x86_64\n")),(0,a.kt)("p",null,"Run this SUSEConnect command to activate the Containers module."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"node:~ # SUSEConnect -p sle-module-containers/15.2/x86_64\nRegistering system to registration proxy https://rmt.seader.us\n\nUpdating system details on https://rmt.seader.us ...\n\nActivating sle-module-containers 15.2 x86_64 ...\n-> Adding service to system ...\n-> Installing release package ...\n\nSuccessfully registered system\n")),(0,a.kt)("p",null,"In order to run docker cli commands with your user then you need to add this user to the ",(0,a.kt)("inlineCode",{parentName:"p"},"docker")," group.\nIt is preferred not to use the root user for this."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"usermod -aG docker <user_name>\n")),(0,a.kt)("p",null,"To verify that the user is correctly configured, log out of the node and login using SSH or your preferred method, and execute ",(0,a.kt)("inlineCode",{parentName:"p"},"docker ps"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"ssh user@node\nuser@node:~> docker ps\nCONTAINER ID        IMAGE       COMMAND             CREATED             STATUS              PORTS               NAMES\nuser@node:~>\n")),(0,a.kt)("h3",{id:"opensuse-microoskubic-atomic"},"openSUSE MicroOS/Kubic (Atomic)"),(0,a.kt)("p",null,"Consult the project pages for openSUSE MicroOS and Kubic for installation"),(0,a.kt)("h4",{id:"opensuse-microos"},"openSUSE MicroOS"),(0,a.kt)("p",null,"Designed to host container workloads with automated administration & patching. Installing openSUSE MicroOS you get a quick, small environment for deploying Containers, or any other workload that benefits from Transactional Updates. As rolling release distribution the software is always up-to-date.\n",(0,a.kt)("a",{parentName:"p",href:"https://microos.opensuse.org"},"https://microos.opensuse.org")),(0,a.kt)("h4",{id:"opensuse-kubic"},"openSUSE Kubic"),(0,a.kt)("p",null,"Based on openSUSE MicroOS, designed with the same things in mind but is focused on being a Certified Kubernetes Distribution.\n",(0,a.kt)("a",{parentName:"p",href:"https://kubic.opensuse.org"},"https://kubic.opensuse.org"),"\nInstallation instructions:\n",(0,a.kt)("a",{parentName:"p",href:"https://kubic.opensuse.org/blog/2021-02-08-MicroOS-Kubic-Rancher-RKE/"},"https://kubic.opensuse.org/blog/2021-02-08-MicroOS-Kubic-Rancher-RKE/")),(0,a.kt)("h3",{id:"red-hat-enterprise-linux-rhel--oracle-linux-ol--centos"},"Red Hat Enterprise Linux (RHEL) / Oracle Linux (OL) / CentOS"),(0,a.kt)("p",null,"If using Red Hat Enterprise Linux, Oracle Linux or CentOS, you cannot use the ",(0,a.kt)("inlineCode",{parentName:"p"},"root")," user as ",(0,a.kt)("a",{parentName:"p",href:"/config-options/nodes/#ssh-users"},"SSH user")," due to ",(0,a.kt)("a",{parentName:"p",href:"https://bugzilla.redhat.com/show_bug.cgi?id=1527565"},"Bugzilla 1527565"),". Please follow the instructions below how to setup Docker correctly, based on the way you installed Docker on the node."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"In RHEL 8.4, two extra services are included on the NetworkManager: ",(0,a.kt)("inlineCode",{parentName:"p"},"nm-cloud-setup.service")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"nm-cloud-setup.timer"),". These services add a routing table that interferes with the CNI plugin's configuration. If these services are enabled, you must disable them using the command below, and then reboot the node to restore connectivity:"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre"},"systemctl disable nm-cloud-setup.service nm-cloud-setup.timer\nreboot\n")),(0,a.kt)("p",{parentName:"admonition"},"In addition, the default firewall settings of RHEL 8.4 prevent RKE1 pods from reaching out to Rancher to connect to the cluster agent. To allow Docker containers to reach out to the internet and connect to Rancher, make the following updates to the firewall settings:"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre"},"  firewall-cmd --zone=public  --add-masquerade --permanent\n  firewall-cmd --reload\n"))),(0,a.kt)("h4",{id:"using-upstream-docker-1"},"Using upstream Docker"),(0,a.kt)("p",null,"If you are using upstream Docker, the package name is ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-ce")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-ee"),". You can check the installed package by executing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"rpm -q docker-ce\n")),(0,a.kt)("p",null,"When using the upstream Docker packages, please follow ",(0,a.kt)("a",{parentName:"p",href:"https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user"},"Manage Docker as a non-root user"),"."),(0,a.kt)("h4",{id:"using-rhelcentos-packaged-docker"},"Using RHEL/CentOS packaged Docker"),(0,a.kt)("p",null,"If you are using the Docker package supplied by Red Hat / CentOS, the package name is ",(0,a.kt)("inlineCode",{parentName:"p"},"docker"),". You can check the installed package by executing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"rpm -q docker\n")),(0,a.kt)("p",null,"If you are using the Docker package supplied by Red Hat / CentOS, the ",(0,a.kt)("inlineCode",{parentName:"p"},"dockerroot")," group is automatically added to the system. You will need to edit (or create) ",(0,a.kt)("inlineCode",{parentName:"p"},"/etc/docker/daemon.json")," to include the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'{\n    "group": "dockerroot"\n}\n')),(0,a.kt)("p",null,"Restart Docker after editing or creating the file. After restarting Docker, you can check the group permission of the Docker socket (",(0,a.kt)("inlineCode",{parentName:"p"},"/var/run/docker.sock"),"), which should show ",(0,a.kt)("inlineCode",{parentName:"p"},"dockerroot")," as group:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"srw-rw----. 1 root dockerroot 0 Jul  4 09:57 /var/run/docker.sock\n")),(0,a.kt)("p",null,"Add the SSH user you want to use to this group, this can't be the ",(0,a.kt)("inlineCode",{parentName:"p"},"root")," user."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"usermod -aG dockerroot <user_name>\n")),(0,a.kt)("p",null,"To verify that the user is correctly configured, log out of the node and login with your SSH user, and execute ",(0,a.kt)("inlineCode",{parentName:"p"},"docker ps"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"ssh <user_name>@node\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n")),(0,a.kt)("h3",{id:"red-hat-atomic"},"Red Hat Atomic"),(0,a.kt)("p",null,"Before trying to use RKE with Red Hat Atomic nodes, there are a couple of updates to the OS that need to occur in order to get RKE working."),(0,a.kt)("h4",{id:"openssh-version"},"OpenSSH version"),(0,a.kt)("p",null,"By default, Atomic hosts ship with OpenSSH 6.4, which doesn't support SSH tunneling, which is a core RKE requirement. If you upgrade to the latest version of OpenSSH supported by Atomic, it will correct the SSH issue."),(0,a.kt)("h4",{id:"creating-a-docker-group"},"Creating a Docker Group"),(0,a.kt)("p",null,"By default, Atomic hosts do not come with a Docker group. You can update the ownership of the Docker socket by enabling the specific user in order to launch RKE."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"# chown <user> /var/run/docker.sock\n")),(0,a.kt)("h3",{id:"flatcar-container-linux"},"Flatcar Container Linux"),(0,a.kt)("p",null,"When using Flatcar Container Linux nodes, it is required to use the following configuration in the cluster configuration file:"),(0,a.kt)(l.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"Canal",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"rancher_kubernetes_engine_config:\n  network:\n    plugin: canal\n    options:\n      canal_flex_volume_plugin_dir: /opt/kubernetes/kubelet-plugins/volume/exec/nodeagent~uds\n      flannel_backend_type: vxlan\n\n  services:\n    kube-controller:\n      extra_args:\n        flex-volume-plugin-dir: /opt/kubernetes/kubelet-plugins/volume/exec/\n"))),(0,a.kt)(o.Z,{value:"Calico",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"rancher_kubernetes_engine_config:\n  network:\n    plugin: calico\n    options:\n      calico_flex_volume_plugin_dir: /opt/kubernetes/kubelet-plugins/volume/exec/nodeagent~uds\n      flannel_backend_type: vxlan\n\n  services:\n    kube-controller:\n      extra_args:\n        flex-volume-plugin-dir: /opt/kubernetes/kubelet-plugins/volume/exec/\n")))),(0,a.kt)("p",null,"It is also required to enable the Docker service, you can enable the Docker service using the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"systemctl enable docker.service\n")),(0,a.kt)("h2",{id:"software"},"Software"),(0,a.kt)("p",null,"This section describes the requirements for Docker, Kubernetes, and SSH."),(0,a.kt)("h3",{id:"openssh"},"OpenSSH"),(0,a.kt)("p",null,"In order to SSH into each node, OpenSSH 7.0+ must be installed on each node."),(0,a.kt)("h3",{id:"kubernetes"},"Kubernetes"),(0,a.kt)("p",null,"Refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/rancher/rke/releases"},"RKE release notes")," for the supported versions of Kubernetes."),(0,a.kt)("h3",{id:"docker"},"Docker"),(0,a.kt)("p",null,"Each Kubernetes version supports different Docker versions. The Kubernetes release notes contain the ",(0,a.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/setup/release/notes/#dependencies"},"current list")," of validated Docker versions."),(0,a.kt)("h3",{id:"installing-docker"},"Installing Docker"),(0,a.kt)("p",null,"Refer to ",(0,a.kt)("a",{parentName:"p",href:"https://ranchermanager.docs.rancher.com/getting-started/installation-and-upgrade/installation-requirements/install-docker"},"Installing Docker")),(0,a.kt)("h3",{id:"checking-the-installed-docker-version"},"Checking the Installed Docker Version"),(0,a.kt)("p",null,"Confirm that a Kubernetes supported version of Docker is installed on your machine, by running ",(0,a.kt)("inlineCode",{parentName:"p"},"docker version --format '{{.Server.Version}}'"),"."),(0,a.kt)("h2",{id:"hardware"},"Hardware"),(0,a.kt)("p",null,"This section describes the hardware requirements for the worker role, large Kubernetes clusters, and etcd clusters."),(0,a.kt)("h3",{id:"worker-role"},"Worker Role"),(0,a.kt)("p",null,"The hardware requirements for nodes with the ",(0,a.kt)("inlineCode",{parentName:"p"},"worker")," role mostly depend on your workloads. The minimum to run the Kubernetes node components is 1 CPU (core) and 1GB of memory."),(0,a.kt)("p",null,"Regarding CPU and memory, it is recommended that the different planes of Kubernetes clusters (etcd, controlplane, and workers) should be hosted on different nodes so that they can scale separately from each other."),(0,a.kt)("h3",{id:"large-kubernetes-clusters"},"Large Kubernetes Clusters"),(0,a.kt)("p",null,"For hardware recommendations for large Kubernetes clusters, refer to the official Kubernetes documentation on ",(0,a.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/setup/best-practices/cluster-large/"},"building large clusters"),"."),(0,a.kt)("h3",{id:"etcd-clusters"},"Etcd Clusters"),(0,a.kt)("p",null,"For hardware recommendations for etcd clusters in production, refer to the official ",(0,a.kt)("a",{parentName:"p",href:"https://etcd.io/docs/v3.5/op-guide/hardware/"},"etcd documentation"),"."),(0,a.kt)("h2",{id:"ports"},"Ports"),(0,a.kt)(s,{mdxType:"PortsRKENodes"}),(0,a.kt)(c,{mdxType:"RequirementsPortsRKE"}),(0,a.kt)("p",null,"If you are using an external firewall, make sure you have this port opened between the machine you are using to run ",(0,a.kt)("inlineCode",{parentName:"p"},"rke")," and the nodes that you are going to use in the cluster."),(0,a.kt)("h3",{id:"opening-port-tcp6443-using-iptables"},"Opening port TCP/6443 using ",(0,a.kt)("inlineCode",{parentName:"h3"},"iptables")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"# Open TCP/6443 for all\niptables -A INPUT -p tcp --dport 6443 -j ACCEPT\n\n# Open TCP/6443 for one specific IP\niptables -A INPUT -p tcp -s your_ip_here --dport 6443 -j ACCEPT\n")),(0,a.kt)("h3",{id:"opening-port-tcp6443-using-firewalld"},"Opening port TCP/6443 using ",(0,a.kt)("inlineCode",{parentName:"h3"},"firewalld")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'# Open TCP/6443 for all\nfirewall-cmd --zone=public --add-port=6443/tcp --permanent\nfirewall-cmd --reload\n\n# Open TCP/6443 for one specific IP\nfirewall-cmd --permanent --zone=public --add-rich-rule=\'\n  rule family="ipv4"\n  source address="your_ip_here/32"\n  port protocol="tcp" port="6443" accept\'\nfirewall-cmd --reload\n')),(0,a.kt)("h2",{id:"ssh-server-configuration"},"SSH Server Configuration"),(0,a.kt)("p",null,"Your SSH server system-wide configuration file, located at ",(0,a.kt)("inlineCode",{parentName:"p"},"/etc/ssh/sshd_config"),", must include this line that allows TCP forwarding:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"AllowTcpForwarding yes\n")))}y.isMDXComponent=!0}}]);